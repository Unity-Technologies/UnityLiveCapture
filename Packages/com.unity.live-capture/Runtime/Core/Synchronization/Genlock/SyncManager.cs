using System;
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;
using UnityEngine.LowLevel;
using UnityEngine.PlayerLoop;
using UnityEngine.Scripting;

namespace Unity.LiveCapture
{
    /// <summary>
    /// The class used to synchronize the engine update loop to an external signal.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When working with video or other data feeds in a live context (ex. broadcast, virtual production), it is important
    /// to ensure that each device in the processing pipeline outputs exactly one frame for every frame of input, and that
    /// all devices process inputs or outputs with steady, predictable timing. This helps to avoid frame drops caused by
    /// devices receiving more frames than they can handle at once (buffer overflows) or devices not having any input frames
    /// to process (buffer underflows).
    /// </para>
    /// <para>
    /// This is usually achieved by feeding a signal that pulses at a specified frame rate (known as the genlock signal) into
    /// all the devices in the pipeline. When the signal is pulsed, every device will output one frame. The genlock signal is
    /// generated by one of the devices in the pipeline or an external reference clock. Devices synchronized in this manner are
    /// said to be genlocked.
    /// </para>
    /// <para>
    /// This class provides a common way to configure the Unity engine update loop to synchronize to an external signal, such
    /// as a genlock signal, instead of executing the update loop as fast as possible or at the refresh rate of the output display.
    /// </para>
    /// </remarks>
    public class SyncManager
    {
        struct SyncUpdate
        {
        }

#if UNITY_EDITOR
        [InitializeOnLoadMethod]
        static void Init()
        {
            if (!PlayerSettings.gcIncremental)
            {
                PlayerSettings.gcIncremental = true;
                Debug.Log("Changed project to use incremental GC to improve synchronization performance. Restart the Editor for this change to take effect.");
            }

            ConfigureGC();
            RegisterUpdate();

            AssemblyReloadEvents.beforeAssemblyReload += OnBeforeAssemblyReload;
            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
        }

        static void OnBeforeAssemblyReload()
        {
            if (Instance.ActiveSyncProvider != null)
            {
                Instance.ActiveSyncProvider.StopSynchronizing();
            }
        }

        static void OnPlayModeStateChanged(PlayModeStateChange state)
        {
            if (Instance.ActiveSyncProvider == null)
            {
                return;
            }

            switch (state)
            {
                case PlayModeStateChange.EnteredEditMode:
                case PlayModeStateChange.EnteredPlayMode:
                    Instance.ActiveSyncProvider.StopSynchronizing();
                    Instance.ActiveSyncProvider.StartSynchronizing();
                    break;
            }
        }
#else
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]
        static void Init()
        {
            if (!GarbageCollector.isIncremental)
            {
                Debug.LogWarning("Consider enabling incremental GC in the player settings to improve synchronization performance.");
            }

            ConfigureGC();
            RegisterUpdate();
        }
#endif

        static void ConfigureGC()
        {
            // Use a few milliseconds as the GC timeslice to help ensure sync pulses are not missed.
            // The default setting is 3 ms.
            GarbageCollector.incrementalTimeSliceNanoseconds = 2 * 1000 * 1000;
        }

        static bool RegisterUpdate()
        {
            var playerLoop = PlayerLoop.GetCurrentPlayerLoop();

            if (!playerLoop.TryFindSubSystem<TimeUpdate>(out var system))
            {
                return false;
            }

            var index = system.IndexOf<TimeUpdate.WaitForLastPresentationAndUpdateTime>();

            if (index < 0)
            {
                return false;
            }

            system.AddSubSystem<SyncUpdate>(index, Update);

            if (!playerLoop.TryUpdate(system))
            {
                return false;
            }

            PlayerLoop.SetPlayerLoop(playerLoop);
            return true;
        }

        /// <summary>
        /// The singleton instance.
        /// </summary>
        public static SyncManager Instance { get; } = new SyncManager();

        /// <summary>
        /// The <see cref="ISyncProvider"/> that is currently in control of the engine update timing.
        /// </summary>
        public ISyncProvider ActiveSyncProvider { get; private set; }

        /// <summary>
        /// An event invoked when a sync provider takes control of the engine update timing.
        /// </summary>
        /// <seealso cref="SyncProviderDeactivated"/>
        public event Action<ISyncProvider> SyncProviderActivated;

        /// <summary>
        /// An event invoked when a sync provider releases control of the engine update timing.
        /// </summary>
        /// <seealso cref="SyncProviderActivated"/>
        public event Action<ISyncProvider> SyncProviderDeactivated;

        /// <summary>
        /// Gets the pulse rate of the synchronization signal.
        /// </summary>
        /// <param name="syncRate">The pulse rate of the synchronization signal.</param>
        /// <returns><see langword="true"/> if there is a valid sync rate; otherwise, <see langword="false"/>.</returns>
        public static bool TryGetSyncRate(out FrameRate syncRate)
        {
            var syncProvider = Instance.ActiveSyncProvider;

            if (syncProvider != null && syncProvider.SyncRate.IsValid)
            {
                syncRate = syncProvider.SyncRate;
                return true;
            }

            syncRate = default;
            return false;
        }

        static void Update()
        {
            // swap the active sync provider if a new provider is selected
            var selectedSyncProvider = LiveCaptureSettings.Instance.SyncProvider;

            if (Instance.ActiveSyncProvider != selectedSyncProvider)
            {
                if (Instance.ActiveSyncProvider != null)
                {
                    Instance.ActiveSyncProvider.StopSynchronizing();
                    Instance.SyncProviderDeactivated?.Invoke(Instance.ActiveSyncProvider);
                }

                Instance.ActiveSyncProvider = selectedSyncProvider;

                if (Instance.ActiveSyncProvider != null)
                {
                    Instance.SyncProviderActivated?.Invoke(Instance.ActiveSyncProvider);
                }
            }

            var syncProvider = Instance.ActiveSyncProvider;

            if (syncProvider == null)
            {
                return;
            }

            // try to start the sync if it is not currently running
            if (syncProvider.Status == SyncStatus.Stopped)
            {
                syncProvider.StartSynchronizing();
            }

            // if the sync is able to run wait for the next sync pulse
            if (syncProvider.Status != SyncStatus.Stopped)
            {
                syncProvider.WaitForNextPulse();
            }
        }
    }
}
